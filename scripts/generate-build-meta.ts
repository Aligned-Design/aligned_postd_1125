#!/usr/bin/env tsx
/**
 * Generate Build Metadata
 * 
 * Creates client/src/build-meta.json with:
 * - buildTime (ISO timestamp)
 * - gitSha (short commit hash)
 * - buildId (random fallback)
 * 
 * This file is imported by the app and rendered as DEPLOY_PROOF marker.
 */

import { execSync } from "child_process";
import { writeFileSync, mkdirSync } from "fs";
import { dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface BuildMeta {
  buildTime: string;
  gitSha: string;
  gitShortSha: string;
  buildId: string;
  nodeEnv: string;
}

function getGitSha(): { full: string; short: string } {
  // Priority 1: Vercel environment variables (production deployments)
  const vercelSha =
    process.env.VERCEL_GIT_COMMIT_SHA ||
    process.env.VERCEL_GITHUB_COMMIT_SHA ||
    process.env.VERCEL_GITLAB_COMMIT_SHA ||
    process.env.VERCEL_BITBUCKET_COMMIT_SHA;

  if (vercelSha) {
    const shortSha = vercelSha.substring(0, 7);
    console.log(`✅ Using Vercel commit SHA: ${shortSha}`);
    return { full: vercelSha, short: shortSha };
  }

  // Priority 2: Local git (development/CI)
  try {
    const fullSha = execSync("git rev-parse HEAD", {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "ignore"],
    }).trim();

    const shortSha = execSync("git rev-parse --short HEAD", {
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "ignore"],
    }).trim();

    console.log(`✅ Using git SHA: ${shortSha}`);
    return { full: fullSha, short: shortSha };
  } catch (error) {
    // Git not available - only acceptable in development
    const nodeEnv = process.env.NODE_ENV || "development";
    
    if (nodeEnv === "production") {
      console.error("❌ FATAL: Missing commit SHA in production build");
      console.error("   VERCEL_* environment variables are absent and git is unavailable");
      console.error("   Cannot deploy without commit traceability");
      process.exit(1);
    }

    console.warn("⚠️  Git not available in development, using fallback SHA");
    return { full: "dev-unknown", short: "dev-unknown" };
  }
}

function generateBuildId(): string {
  return Math.random().toString(36).substring(2, 10);
}

function main() {
  const buildTime = new Date().toISOString();
  const { full: gitSha, short: gitShortSha } = getGitSha();
  const buildId = generateBuildId();
  const nodeEnv = process.env.NODE_ENV || "development";

  const buildMeta: BuildMeta = {
    buildTime,
    gitSha,
    gitShortSha,
    buildId,
    nodeEnv,
  };

  const outputPath = `${__dirname}/../client/src/build-meta.json`;
  const envPath = `${__dirname}/../.env.production.local`;

  // 1. Ensure directory exists and write JSON file (for backwards compatibility)
  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, JSON.stringify(buildMeta, null, 2), "utf-8");

  // 2. Write environment variables file for Vite (preferred for DeployProof)
  // This avoids TypeScript compile-time errors from importing generated files
  const envContent = [
    `# Auto-generated by scripts/generate-build-meta.ts`,
    `# Do not commit this file - it's regenerated on each build`,
    `VITE_GIT_SHA=${gitSha}`,
    `VITE_GIT_SHORT_SHA=${gitShortSha}`,
    `VITE_BUILD_TIME=${buildTime}`,
    `VITE_BUILD_ID=${buildId}`,
    ``,
  ].join("\n");
  
  writeFileSync(envPath, envContent, "utf-8");

  console.log("✅ Build metadata generated:");
  console.log(`   buildTime: ${buildTime}`);
  console.log(`   gitSha: ${gitShortSha}`);
  console.log(`   buildId: ${buildId}`);
  console.log(`   nodeEnv: ${nodeEnv}`);
  console.log(`   → JSON: ${outputPath}`);
  console.log(`   → ENV:  ${envPath}`);
}

main();

